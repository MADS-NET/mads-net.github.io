---
title: "Real-time visualization with Rerun"
author:
  - name: "Paolo Bosetti"
    affiliations: 
      - name: "University of Trento"
date: 09/10/2025
date-modified: today
format: html
# or uncomment the following line to also create PDF format
# format: 
#   html:
#     toc: true
#   pdf:
#     toc: true
draft: false
categories: [easy, visualizaztion, operations, plugin]
abstract: |
  Rerun.io is a powerful tool for real-time visualization and debugging of robotics applications. This guide introduces the rerunner plugin, which allows to capture MADS packets and feed them to the rerun viewer to get real-time plots of signals.
---


```{r setup, inlude=FALSE, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(readr)
```

# Introduction

[Rerun.io](https://rerun.io/) is a powerful tool for real-time visualization and debugging of robotics applications. It allows developers to visualize data from their applications in real-time, making it easier to identify issues and understand system behavior. It supports visualization of 2-D plots and time-series, 3-D cloud points and scenes, tabulated data, heatmaps and tensor maps. Rerun is made by two components: The library, which is integrated into the application to capture and send data, and the viewer GUI, which displays the data in a user-friendly interface.

The [`rerunner`](https://github.com/MADS-NET/rerunner_plugin) plugin is a MADS sink plugin that integrates the Rerun library into MADS. It captures MADS packets and feeds them to the Rerun viewer, allowing users to visualize data from their MADS applications in real-time.

# The plugin

## Installation

To obtain and install the plugin, follow instructions on the [GitHub page](https://github.com/MADS-NET/rerunner_plugin). Note that you'll have to download separately the Rerun library, as described in the instructions or following this [link](https://rerun.io/docs/getting-started/installing-viewer#installing-the-viewer). Once you have compiled and installed the plugin, you can quickly test it together with the [`replay`](https://github.com/MADS-NET/replay_plugin) source plugin, which is used to publish a previously recorded MADS log file. In the following, we are assuming that you have it installed and that followed [its guide](replay.html).


## Usage

### Keypaths

The plugin uses the concept of **keypaths** to tap into JSON messages and extract data to be sent to the Rerun viewer. A keypath is a string that specifies the path to a specific field in a JSON object, using slash notation to separate nested fields. For example, the keypath `/sensor/temperature` would refer to the `temperature` field inside the `sensor` object:

```json
{
  "sensor": {
    "temperature": 25.3,
    "humidity": 60
  }
}
```

Furthermore, the plugin can subscribe to multiple MADS topics, so a keypath is actually prepended with the topic name. So, according to the example above, if the message is published on the topic `env`, the full keypath to access the temperature field would be `/env/sensor/temperature`.

If a JSON object contains an array, you can use numbers to access individual elements. For example, the keypath `/sensors/0/temperature` would refer to the `temperature` field of the first element in the `sensors` array:

```json
{
  "sensors": [
    {
      "temperature": 25.3,
      "humidity": 60
    },
    {
      "temperature": 26.1,
      "humidity": 55
    }
  ]
}
```

::: callout-important
Keypaths **must** start with a leading slash: `/sensor/x` os OK, `sensor/x` is wrong.
:::

An alternative syntax uses dots and square brakets for array indexes, as for example in `topic.sensor[0].temperature`. This alterante syntax less efficient and it is mostly supported for similarity to the [replay plugin](replay.qmd).

### Visualizations

The plugin supports the visualization of scalar values as **time series**. If the INI file contains the following section:

```toml
[rerunner]
sub_topics = ["env"]
keypaths = ["/env/sensor/temperature", "/env/sensor/humidity"]
```

then the Rerun viewer will display two time series for the temperature and humidity values. The layout of the two series is heuristically determined by the viewer, but it can be customized by the user in the viewer GUI.

For the time-series, the plugin assumes that the JSON messages contain a field named `timeframe` with the timeframe of the measurement, expressed in seconds since last midnight rounded to the nearest frame. If the field is not present, the plugin will use the current system time as timestamp.

At the moment, the plugin can also visualize the **Auto-Correlation Function** ([ACF](https://en.wikipedia.org/wiki/Autocorrelation)) and **Fast Fourier Transform** (FFT) of selected signals. The ACF is useful for visualizing periodicity in the signal and --- most importantly --- to define the maximum sampling frequency for a signal (above that frequency we are essentially sampling the same observation).

To also plot ACFs and FFTs, select the desired signals and set the running window size as follows:

```toml
window_size = 500
acf_keypaths = ["/env/sensor/temperature", "/env/sensor/humidity"]
fft_keypaths = ["/env/sensor/temperature", "/env/sensor/humidity"]
```

The plugin currently also calculates, for each selected signal, its average, standard deviation, and standard uncertainty. Also, it provides statistics on the time-steps.

::: callout-tip
# More complex viewers
It is relatively easy to customize the `RerunnerPlugin` class to add more or different viewers, including animating 3-D scenes with real-time data. Follow the [Rerun guides](https://rerun.io/docs) for that.
:::


## Paths in Rerun

The Rerun viewer receives data organized in **paths**, using the same slash syntax above described. You can expect the followings:

* `data/*`: the raw data as time series
* `acf_plot/*`: the autocorrelation function plots
* `fft_plot/*`: the autocorrelation function plots
* `stats/mean/*`: the running mean for the same signals in `data/`
* `stats/stdev/*`: the running standard deviation for the same signals in `data/`
* `stats/std_uncertainty/*`: the running standard uncertainty for the same signals in `data/`
* `timestep`: the time series of data timesteps
* `mean_timestep`: the running mean for the data timesteps

Using the Rerun viewer GUI it is easy to add/remove and rearrange plots for individual data series.


## Rerun blueprints

The Rerun viewer supports **blueprints**. A blueprint is actually a description of the panels layout in the viewer and of their content (type and configuration of graphical elements). In the absence of a blueprint specified by the user, the Rerun viewer heuristically creates one by itself. Starting from that, the user can rearrange panels and charts to his/her likings, and then **save the blueprint** as a `.rbl` file.

![Save blueprint](images/blueprint.png){width=50%}

Once you have a blueprint file, you can load it upon launching the `rerunner.plugin`, in two different ways:

* by adding a line `blueprint = "path/to/a/.rbl/file"` to the `[rerunner]` INI section
* by passing the option to the plugin command line: `mads sink rerunner.plugin -o blueprint=path` (this requires mads version 1.4.x)

The command line options overrides any settings in the INI file.

# Example usage

We are using the `replay` plugin to reproduce in loop a CSV file generated with synthetic data. The datafile contains two signals, `sensor.temperature` and `sensor.humidity`, published on the topic `replay`. The temperature signal is generated with a sinusoidal plus some Gaussian noise. the humidity signal is generated with as an ARIMA(2,0,4) process, so that we expect to have 3-4 lags of autocorrelation.

```{r}
#| echo: false
set.seed(0)
N <- 500
dt <- 0.1
T <- N*dt
f <- 2*pi/T *2
d <- 0 # diff order
df <- tibble(
  id = 1:N,
  timecode = (id-1)*dt,
  sensor.temperature = 10*sin(timecode*f) + rnorm(100, 0, 2),
  sensor.humidity = NA
)
df$sensor.humidity <- list(
  ar = c(0.7, -0.4),
  ma = c(0.2, 0.5, 0.2, 0.1),
  order = c(2, d, 4)
) %>% arima.sim(N-d) + 20

df %>% 
  select(-timecode) %>% 
  write_csv("example.csv")

```

```{r, dev.args=list(bg = "transparent")}
#| echo: false
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 3
#| dev: png
df %>%
  pivot_longer(cols = starts_with("sensor")) %>%
  mutate(name = str_remove(name, "sensor.")) %>%
  ggplot(aes(x=timecode, y=value, color=name)) + 
  geom_line() + 
  labs(color="signal") 
```

The ACF and PACF charts of the humidity signal are:

```{r, dev.args=list(bg = "transparent")}
#| echo: false
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 3
#| dev: png
forecast::ggtsdisplay(df$sensor.humidity)
```

We observe that in the ACF chart the lags 1--3 are significant.

These data are available in the `example.csv` file in the `rerunner_plugin` repository.

To quickly test the `rerunner` plugin, we follow the next steps:

1. Install the [`replay`](https://github.com/MADS-NET/replay_plugin) source plugin
2. Start the MADS broker
3. Configure the `replay.plugin` with this INI section:

```toml
[replay]
pub_topic = "replay"
period = 10
csv_file = "example.csv"
loop = true
```

4. Clone the `rerunner` plugin: `git clone https://github.com/MADS-NET/rerunner_plugin.git`
5. From the `rerunner_plugin` folder, run the `replay` plugin, so that it uses the `example.csv` file *from the current folder*:

```sh
mads source replay.plugin
```

6. Configure the INI file withe the following:

```toml
[rerunnner]
sub_topic = ["replay"] # Topics to subscribe
time = ""              # Use system time
window_size = 200      # ACF running windows width
keypaths = ["/replay/sensor/temperature", "/replay/sensor/humidity"]
acf_keypaths = ["/replay/sensor/temperature", "/replay/sensor/humidity"]
fft_keypaths = ["/replay/sensor/temperature", "/replay/sensor/humidity"]
```

7. Launch the Rerun viewer
8. From a new terminal, compile and launch the `rerunner` plugin:

```sh
cmake -Bbuild -DCMAKE_INSTALL_PREFIX=$(mads -p)
cmake --build build -j6
mads sink build/rerunner.plugin
```

9. The plugin will start collecting the data streamed on the `replay` topic and plotting it on the viewer:

![Rerun viewer output](images/rerun.png)

In particular, note that the ACF file for the humidity signal shows significant lags at 1, 2 and 3, as expected, while the temperature signal a long ACF as expected by such a periodic signal.